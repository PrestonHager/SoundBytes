'use strict';

/**
 * SERVERLESS PLATFORM CLIENT SDK: UTILS
 */

const https = require('https');
const urlUtils = require('url');
const traverse = require('traverse');
const minimatch = require('minimatch');
const {
  Login: TencentAuth,
  Others: TencentUtils,
  Cam: TencentCAM,
  Debug: TencentDebug,
} = require('@serverless/utils-china');

const utils = {};

/**
 * Wait for a number of miliseconds
 * @param {*} wait
 */
const sleep = async (wait) => new Promise((resolve) => setTimeout(() => resolve(), wait));

/**
 * Make HTTP API requests, easily
 * @param {*} options.endpoint
 * @param {*} options.data
 * @param {*} options.accessKey
 * @param {*} options.method
 */
const request = async (options) => {
  const url = urlUtils.parse(options.endpoint);
  const requestOptions = {
    protocol: url.protocol,
    hostname: url.hostname,
    port: url.port,
    path: url.path,
    method: options.method || 'POST',
    headers: options.headers || {
      'Content-Type': 'application/json',
    },
  };

  if (options.accessKey) {
    requestOptions.headers.authorization = `Bearer ${options.accessKey}`;
  }

  const requestWrap = () =>
    new Promise((resolve, reject) => {
      const req = https.request(requestOptions, (res) => {
        res.setEncoding('utf8');
        let rawData = '';
        res.on('data', (chunk) => {
          rawData += chunk;
        });
        res.on('end', () => {
          if (!res.complete) {
            return reject(
              new Error('The connection was terminated while the message was still being sent.')
            );
          }
          if (!rawData && res.statusCode < 400) {
            return resolve();
          }
          try {
            const data = JSON.parse(rawData);
            if (res.statusCode >= 400) {
              const error = new Error(
                data.message ||
                  `${res.statusCode} error of ${requestOptions.method} ${options.endpoint}`
              );
              error.response = {
                status: res.statusCode,
                data,
              };
              return reject(error);
            }
            return resolve(data);
          } catch (e) {
            const error = new Error(
              `Failed pass returning data of ${requestOptions.method} ${options.endpoint}`
            );
            error.response = {
              status: res.statusCode,
              data: rawData,
            };
            return reject(error);
          }
        });
      });

      req.on('error', (e) => {
        reject(e);
      });

      if (options.data) {
        req.write(options.data);
      }
      req.end();
    });

  try {
    return await requestWrap();
  } catch (error) {
    // log the request so that we could debug that stubborn random publish error.
    if (error.response && error.response.status && error.response.data.message) {
      throw new Error(`${error.response.status} - ${error.response.data.message}`);
    }
    throw error;
  }
};

/**
 * Resolves any variables that require resolving before the engine.
 * This currently supports only ${env}.  All others should be resolved within the deployment engine.
 * @param {*} inputs
 */
const resolveInputEnvVariables = (inputs) => {
  const regex = /\${(\w*:?[\w\d.-]+)}/g;
  let variableResolved = false;
  const resolvedInputs = traverse(inputs).forEach(function (value) {
    const matches = typeof value === 'string' ? value.match(regex) : null;
    if (matches) {
      let newValue = value;
      for (const match of matches) {
        // Search for ${env:}
        if (/\${env:(\w*[\w.-_]+)}/g.test(match)) {
          const referencedPropertyPath = match.substring(2, match.length - 1).split(':');
          newValue = process.env[referencedPropertyPath[1]];
          variableResolved = true;
        }
      }
      this.update(newValue);
    }
  });
  if (variableResolved) {
    return resolveInputEnvVariables(resolvedInputs);
  }
  return resolvedInputs;
};

// Add to utils object
utils.sleep = sleep;
utils.request = request;
utils.resolveInputEnvVariables = resolveInputEnvVariables;

/**
 *
 * Only load these Utilies when in a Node.js Environment
 *
 */

if (typeof window === 'undefined') {
  const path = require('path');
  const fs = require('fs');
  const archiver = require('archiver');
  const { parseUrl } = require('url');
  const HttpsProxyAgent = require('https-proxy-agent');
  const { readdir, stat: fsStat } = require('fs-extra');
  const pipeline = require('pify')(require('stream.pipeline-shim'));

  const getAgent = () => {
    // Use HTTPS Proxy (Optional)
    const proxy =
      process.env.proxy ||
      process.env.HTTP_PROXY ||
      process.env.http_proxy ||
      process.env.HTTPS_PROXY ||
      process.env.https_proxy;

    const agentOptions = {};
    if (proxy) {
      Object.assign(agentOptions, parseUrl(proxy));
    }

    const ca = process.env.ca || process.env.HTTPS_CA || process.env.https_ca;

    let caCerts = [];

    if (ca) {
      // Can be a single certificate or multiple, comma separated.
      const caArr = ca.split(',');
      // Replace the newline -- https://stackoverflow.com/questions/30400341
      caCerts = caCerts.concat(caArr.map((cert) => cert.replace(/\\n/g, '\n')));
    }

    const cafile = process.env.cafile || process.env.HTTPS_CAFILE || process.env.https_cafile;

    if (cafile) {
      // Can be a single certificate file path or multiple paths, comma separated.
      const caPathArr = cafile.split(',');
      caCerts = caCerts.concat(caPathArr.map((cafilePath) => fs.readFileSync(cafilePath.trim())));
    }

    if (caCerts.length > 0) {
      Object.assign(agentOptions, {
        rejectUnauthorized: true,
        ca: caCerts,
      });
    }

    if (proxy) {
      return new HttpsProxyAgent(agentOptions);
    } else if (agentOptions.ca) {
      return new https.Agent(agentOptions);
    }
    return undefined;
  };

  /**
   * Get the size of a directory
   * @param {string} p path to directory
   */
  const getDirSize = async (p) => {
    const stat = fs.statSync(p);
    if (stat.isFile()) {
      return stat.size;
    } else if (stat.isDirectory()) {
      const entries = fs.readdirSync(p);
      return Promise.all(entries.map((e) => getDirSize(path.join(p, e)))).then((e) =>
        e.reduce((a, c) => a + c, 0)
      );
    }
    return 0;
    // can't take size of a stream/symlink/socket/etc
  };

  const readFiles = async (input, exclude) => {
    const inputPath = path.resolve(input);
    const base = path.resolve(process.cwd(), input);
    const files = [];
    let totalSize = 0;

    const readDir = async (dir) => {
      const items = await readdir(dir);
      itemIteration: for (const item of items) {
        const itemPath = path.resolve(dir, item);
        const relativeItemPath = path.relative(base, itemPath);

        for (const excludeItem of exclude) {
          if (minimatch(relativeItemPath, excludeItem, { nocase: true, dot: true })) {
            continue itemIteration;
          }
        }

        const fsItem = await fsStat(itemPath);
        if (fsItem.isDirectory()) {
          await readDir(itemPath);
        } else {
          totalSize += fsItem.size;
          files.push(relativeItemPath);
        }
      }
    };

    await readDir(inputPath);
    return { files, totalSize };
  };

  const readableByte = (bytes) => {
    if (bytes < 1000) {
      return `${bytes}b`;
    }
    const exp = Math.log(bytes) / Math.log(1000);
    const unit = 'KMGTP'.charAt(Math.floor(exp - 1));
    const size = (bytes / Math.pow(1000, Math.floor(exp))).toFixed(1);
    return `${size}${unit}`;
  };

  const zipAndUpload = async (
    inputDirPath,
    inputContents,
    exclude,
    targetUploadUrl,
    statusReporter
  ) => {
    const url = urlUtils.parse(targetUploadUrl);
    const req = https.request({
      protocol: url.protocol,
      hostname: url.hostname,
      port: url.port,
      path: url.path,
      method: 'PUT',
    });
    const archive = archiver('zip');
    const { files, totalSize } = await readFiles(inputDirPath, exclude);

    if (statusReporter) {
      // report progress if uploading more than 10mb code
      if (totalSize > 10 * 1024 * 1024) {
        const startTime = Date.now();
        req.on('drain', () => {
          const bytesWritten = req.connection.bytesWritten;
          const timeElapse = Date.now() - startTime;
          statusReporter(
            `Uploading ${readableByte(bytesWritten)} ${readableByte(
              (bytesWritten / timeElapse) * 1000
            )}/s`
          );
        });
      }
      // clear status when stream end
      archive.on('end', () => statusReporter());
      archive.on('close', () => statusReporter());
    }

    const uploadPromise = pipeline(archive, req);

    // zip input dir
    for (const file of files) {
      archive.append(fs.createReadStream(path.resolve(inputDirPath, file)), {
        name: file,
      });
    }

    // zip input contents
    if (inputContents) {
      for (const [fileName, fileContent] of Object.entries(inputContents)) {
        archive.append(fileContent, { name: fileName });
      }
    }

    archive.finalize();

    return uploadPromise;
  };

  const isChinaUser = () => {
    const chinaUserDetector = new TencentUtils.IsInChina();
    const { IsInChina: result } = chinaUserDetector.inChina();
    return result;
  };

  const loginWithTencent = async () => {
    let isLoggedIn = false;
    if (process.env.TENCENT_SECRET_ID && process.env.TENCENT_SECRET_KEY) {
      try {
        await getOrgId();
        isLoggedIn = true;
      } catch (e) {
        if (e.code === 'AuthFailure.TokenFailure') {
          // token expired, re-login
          isLoggedIn = false;
        } else {
          throw e;
        }
      }
    }
    if (!isLoggedIn) {
      const tencentAuth = new TencentAuth();
      const credentials = await tencentAuth.login();
      if (!credentials) {
        throw new Error('failed to log into Tencent cloud');
      }
      return [true, credentials];
    }
    return [false, null];
  };

  const getOrgId = async () => {
    const userInfoGetter = new TencentCAM.GetUserInformation();
    const { AppId: orgId } = await userInfoGetter.getUserInformation({
      SecretId: process.env.TENCENT_SECRET_ID,
      SecretKey: process.env.TENCENT_SECRET_KEY,
      token: process.env.TENCENT_TOKEN,
    });
    return String(orgId);
  };

  const tencentDebug = {};
  const getTencentDebug = (functionName, region) => {
    const key = `${functionName}-${region}`;
    if (!tencentDebug[key]) {
      tencentDebug[key] = new TencentDebug(
        {
          SecretId: process.env.TENCENT_SECRET_ID,
          SecretKey: process.env.TENCENT_SECRET_KEY,
          token: process.env.TENCENT_TOKEN,
        },
        { functionName },
        region
      );
    }
    return tencentDebug[key];
  };

  const startTencentRemoteLogAndDebug = async (functionName, region, cliCallback) => {
    return await getTencentDebug(functionName, region).remoteDebug(cliCallback);
  };

  const stopTencentRemoteLogAndDebug = async (functionName, region, cliCallback) => {
    return await getTencentDebug(functionName, region).stop(cliCallback);
  };

  const buildTempAccessKeyForTencent = (credentials) => {
    if (credentials.Token) {
      return `${credentials.SecretId}-${credentials.SecretKey}-${credentials.Token}`;
    }
    return `${credentials.SecretId}-${credentials.SecretKey}`;
  };

  const parseCredentialFromTempAccessKey = (key) => {
    const parts = key.split('-');
    if (parts.length >= 2) {
      return {
        SecretId: parts[0],
        SecretKey: parts[1],
        Token: parts[2],
      };
    }
    return {};
  };

  // Add to utils object
  utils.getAgent = getAgent;
  utils.getDirSize = getDirSize;
  utils.zipAndUpload = zipAndUpload;
  utils.isChinaUser = isChinaUser;
  utils.loginWithTencent = loginWithTencent;
  utils.getOrgId = getOrgId;
  utils.startTencentRemoteLogAndDebug = startTencentRemoteLogAndDebug;
  utils.stopTencentRemoteLogAndDebug = stopTencentRemoteLogAndDebug;
  utils.buildTempAccessKeyForTencent = buildTempAccessKeyForTencent;
  utils.parseCredentialFromTempAccessKey = parseCredentialFromTempAccessKey;
}

// Export
module.exports = utils;
